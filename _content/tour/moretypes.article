Додаткові типи: структури, зрізи та карти.
Навчіться визначати типи на основі вже існуючих: в цьому уроці розглядаються структури, масиви, зрізи та карти.

Автори Go
https://golang.org

* Вказнівники

В Go є вказівники (також використовуються терміни "поінтери" та "покажчики").
Вказівник містить адресу пам'яті значення. ?????

Тип *T є вказівником на значення типу T. Його нульове значення nil.

	var p *int

Оператор `&` генерує вказівник на свій операнд.

	i := 42
	p = &i

Оператор `*` відображає значення, на яке посилається вказівник.

	fmt.Println(*p) // читання i через вказівник p
	*p = 21         // задати i через вказівник p

Це відомо як розіменування.

На відміну від C, Go не має арифметики вказівників.

.play moretypes/pointers.go

* структури

Структура `struct` це набір полів.

.play moretypes/structs.go

* Поля структури

Доступ до полів структури здійснюється за допомогою крапки.

.play moretypes/struct-fields.go

* Вказівник на структури

Доступ до полів структури можна отримати через поінтер структури.

Щоб отримати доступ до поля `X` структури, коли ми маємо вказівник структури `p`, ми можемо 
написати `(*p).X`.
Однак ця нотація є громіздкою, тому мова дозволяє нам натомість писати лише `p.X` без явного 
розіменування.

.play moretypes/struct-pointers.go

* Літерали структури

Літерал структури позначає щойно виділене значення структури шляхом переліку значень її полів.

Ви можете перерахувати лише підмножину полів, використовуючи синтаксис `Name:`. (І порядок іменованих полів не має значення.)

Спеціальний префікс `&` повертає вказівник на значення структури.

.play moretypes/struct-literals.go


* Масиви

Тип `[n]T` — це масив із `n` значень типу `T`.

Вираз

	var a [10]int

оголошує змінну `a` як масив із десяти цілих чисел.

Довжина масиву є частиною його типу, тому розмір масиву не можна змінити.
Це здається обмеженим, але не хвилюйтеся;
Go забезпечує зручний спосіб роботи з масивами.

.play moretypes/array.go


* Зрізи (слайси)

Масив має фіксований розмір.
З іншого боку, зріз — це гнучке представлення елементів 
масиву динамічного розміру.
На практиці зрізи зустрічаються набагато частіше, ніж масиви.

Тип '[]T' є зрізом з елементами типу 'T'.

Зріз формується шляхом зазначення двох індексів, нижньої 
та верхньої меж, розділених двокрапкою:

	a[нижня : верхня]

Це вибирає напіввідкритий діапазон, який включає перший 
елемент, але виключає останній.

Наступний вираз створює фрагмент, який включає елементи з 1 по 3 масиву 'a':

	a[1:4]

.play moretypes/slices.go


* Зрізи схожі на посилання на масиви

Фрагмент не зберігає жодних даних, 
він просто описує розділ основного масиву.

Зміна елементів фрагмента змінює відповідні 
елементи його основного масиву.

Інші фрагменти, які мають той самий базовий масив, побачать ці зміни.

.play moretypes/slices-pointers.go


* Літерали зрізів

Літерал слайсу схожий на літерал масиву без довжини.

Це літерал масиву:

	[3]bool{true, true, false}

І це створює той самий масив, що й вище, а 
потім будує фрагмент, який посилається на нього:

	[]bool{true, true, false}

.play moretypes/slice-literals.go


* Зріз за замовчуваням

Під час створення зрізу ви можете опустити верхню або нижню межі, щоб замість них використовувати стандартні значення.

За замовчуванням для нижньої межі встановлено нуль, а для верхньої – довжина зрізу.

Для масиву

	var a [10]int

ці вирази зрізу еквівалентні:

	a[0:10]
	a[:10]
	a[0:]
	a[:]

.play moretypes/slice-bounds.go


* Довжина і ємність зрізу

Зріз має як _довжину_, так і _ємність_.

Довжина слайсу - це кількість елементів, які він містить.

Ємність слайсу — це кількість елементів у базовому масиві, 
починаючи з першого елемента фрагмента.

Довжину та ємність слайсу `s` можна отримати за допомогою виразів 
`len(s)` і `cap(s)`.

Ви можете збільшити довжину слайсу, зробивши слайс повторно, 
за умови, що він має достатню ємність. 
Спробуйте змінити одну з операцій слайсу в прикладі програми, щоб розширити його 
за межі його можливостей, і подивіться, що станеться.

.play moretypes/slice-len-cap.go


* Нульові зрізи

Нульове значення зрізу дорівнює nil.

Нульовий фрагмент має довжину та ємність 0
і не має під собою масиву.

.play moretypes/nil-slices.go


* Створення зрізу за допомогою make

Зрізи можна створювати за допомогою вбудованої функції `make`;
таким чином ви створюєте масиви динамічного розміру.

Функція `make` виділяє обнулений масив 
і повертає зріз, який посилається на цей масив:

	a := make([]int, 5)  // len(a)=5

Щоб указати ємність, передайте третій аргумент функції `make`:

	b := make([]int, 0, 5) // len(b)=0, cap(b)=5

	b = b[:cap(b)] // len(b)=5, cap(b)=5
	b = b[1:]      // len(b)=4, cap(b)=4

.play moretypes/making-slices.go


* Зрізи зрізів

Зрізи можуть вміщати будь-який тип, включаючи інші зрізи

.play moretypes/slices-of-slice.go


* Додавання до зрізу

Зазвичай до слайсу додаються нові елементи, тому Go надає вбудовану
функцію `append`. [[/pkg/builtin/#append][Документація]]
вбудованого пакета описує `append`.

	func append(s []T, vs ...T) []T

Перший параметр `s` функції `append` це зріз типу `T`, а решта - це значення
`T`, які необхідно додати до зрізу.

Отримане значення функції `append` це зріз, який вміщає всі елементи
вихідного слайса плюс додані значення.

Якщо масив, на який посилається зріз `s` занадто малий, щоб вмістити додані елементи, виділяється 
більший масив. Зріз, який повертається функцією, буде посилатись на щойно виділений 
масив.

(Щоб дізнатись більше про зрізи, прочитайте статтю [[/blog/go-slices-usage-and-internals][Slices: usage and internals]].)

.play moretypes/append.go


* Діапазон (range)

Форма `range` з циклу `for` дозволяє пройти (ітерутватись) по елементам зрізу чи мапи.

Під час застосування range до зрізу для кожної ітерації повертаються два значення.
Перше — це індекс, а друге — копія елемента за цим індексом.

.play moretypes/range.go

* Діапазон (range) продовження

Ви можете пропустити індекс або значення, призначивши `_` замість змінної.

    for i, _ := range pow
    for _, value := range pow

Якщо вам потрібен лише індекс, ви можете опустити другу змінну.

    for i := range pow

.play moretypes/range-continued.go

* Exercise: Slices

Implement `Pic`. It should return a slice of length `dy`, each element of which is a slice of `dx` 8-bit unsigned integers. When you run the program, it will display your picture, interpreting the integers as grayscale (well, bluescale) values.

The choice of image is up to you. Interesting functions include `(x+y)/2`, `x*y`, and `x^y`.

(You need to use a loop to allocate each `[]uint8` inside the `[][]uint8`.)

(Use `uint8(intValue)` to convert between types.)

.play moretypes/exercise-slices.go

* Maps

A map maps keys to values.

The zero value of a map is `nil`.
A `nil` map has no keys, nor can keys be added.

The `make` function returns a map of the given type,
initialized and ready for use.

.play moretypes/maps.go

* Map literals

Map literals are like struct literals, but the keys are required.

.play moretypes/map-literals.go

* Map literals continued

If the top-level type is just a type name, you can omit it from the elements of the literal.

.play moretypes/map-literals-continued.go

* Mutating Maps

Insert or update an element in map `m`:

	m[key] = elem

Retrieve an element:

	elem = m[key]

Delete an element:

	delete(m, key)

Test that a key is present with a two-value assignment:

	elem, ok = m[key]

If `key` is in `m`, `ok` is `true`. If not, `ok` is `false`.

If `key` is not in the map, then `elem` is the zero value for the map's element type.

*Note:* If `elem` or `ok` have not yet been declared you could use a short declaration form:

	elem, ok := m[key]

.play moretypes/mutating-maps.go

* Exercise: Maps

Implement `WordCount`.  It should return a map of the counts of each “word” in the string `s`. The `wc.Test` function runs a test suite against the provided function and prints success or failure.

You might find [[/pkg/strings/#Fields][strings.Fields]] helpful.

.play moretypes/exercise-maps.go

* Function values

Functions are values too. They can be passed around just like other values.

Function values may be used as function arguments and return values.

.play moretypes/function-values.go

* Function closures

Go functions may be closures. A closure is a function value that references variables from outside its body. The function may access and assign to the referenced variables; in this sense the function is "bound" to the variables.

For example, the `adder` function returns a closure. Each closure is bound to its own `sum` variable.

.play moretypes/function-closures.go

* Exercise: Fibonacci closure

Let's have some fun with functions.

Implement a `fibonacci` function that returns a function (a closure) that
returns successive [[https://en.wikipedia.org/wiki/Fibonacci_number][fibonacci numbers]]
(0, 1, 1, 2, 3, 5, ...).

.play moretypes/exercise-fibonacci-closure.go

* Congratulations!

You finished this lesson!

You can go back to the list of [[/tour/list][modules]] to find what to learn next, or continue with the [[javascript:click('.next-page')][next lesson]].
