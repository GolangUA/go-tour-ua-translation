Методи та інтерфейси
Цей урок охоплює такі поняття як методи та інтерфейси - конструкції, які визначають об'єкти та їх поведінку.

Автори Go
https://golang.org

* Методи (англ. methods)

Go не має класів.
Але це не означає, що ви не можете визначати методи для типів.

Метод - це функція, в сигнатурі якої є аргумент-отримувач (англ. method receiver).

Отримувач знаходиться в окремому списку аргументів, між ключовим словом `func` та ім'ям методу.

У цьому прикладі метод `Abs` має аргумент-отримувач `v` типу `Vertex`.

.play methods/methods.go

* Методи - це функції

Пам'ятайте, що метод - це є функція з аргументом-отримувачем.

У прикладі, який ви зараз бачите, `Abs` написана як звичайна функція без будь-якої зміни її функціональної поведінки.

* Методи, продовження

Ви також маєте змогу визначати методи для неструктурних типів.

У цьому прикладі ми бачимо числовий тип `MyFloat`, для якого визначений метод `Abs`.

Тип аргумента-отримувача і метод, який ви визначаєте, повинні належати одному пакету.

Інакше кажучи, ви не можете визначити метод, тип аргумента-отримувача якого належить іншому пакету, ніж пакет, до якого належить метод (це справедливо і для вбудованих типів даних, на кшталт `int`).

.play methods/methods-continued.go

* Вказівники у якості аргументів-отримувачів

Ви маєте змогу визначати методи, у яких аргументами-отримувачами виступають вказівники.

Це означає, що аргумент-отримувач має тип `*T` для деякого типу `T`. (Зауважте, що тип `T` не може бути вказівником сам по собі, наприклад `*int`; інакше кажучи - вказівник на вказівник).

У прикладі ми бачимо, що в методі `Scale` аргумент-отримувач - це вказівник `*Vertex`.

Методи з вказівниками у якості аргументів-отримувачів мають змогу модифікувати значення, на які вказує вказівник (що і робить `Scale`).
Оскільки у функції методів часто закладають можливості модифікації своїх аргументів-отримувачів, вказівники в якості аргументів-отримувачів дають більше можливостей, ніж аргумент-отримувач в якості значення.

Спробуйте прибрати `*` з оголошення методу в рядку 16 і поспостерігайте, як зміниться поведінка програми.

Якщо аргумент-вказівник передається як значення, метод `Scale` оперує копією оригінального значення `Vertex` (тобто так само як зі звичайним аргументом функції).
Метод `Scale` повинен мати вказівник у якості аргумента-отримувача, щоб мати змогу модифікувати значення `Vertex`, яке оголошено у функції `main`.

.play methods/methods-pointers.go

* Вказівники і функції

У прикладі, який ви бачите, методи `Abs` та `Scale` переписані як функції.

А тепер ще раз спробуйте прибрати `*` з рядка 16 (функція `Scale`).
Бачите, чому поведінка програми змінилась?
Які зміни необхідно внести в програму для її успішної компіляції? 
Якщо не впевнені, гортайте на наступну сторінку.

.play methods/methods-pointers-explained.go

* Методи та розіменування вказівника (англ. pointer inderection)

Порівнюючи дві попередні програми, ви могли помітити, що функції з вказівниками у якості аргументів, повинні приймати вказівники у якості параметрів:

	var v Vertex
	ScaleFunc(v, 5)  // помилка компіляції!
	ScaleFunc(&v, 5) // ок

водночас методи з вказівниками у якості аргументів-отримувачів можуть викликатись, коли аргумент-отримувач є або вказівником, або значенням:

	var v Vertex
	v.Scale(5)  // аргумент-отримувач як значення - ок
	p := &v
	p.Scale(10) // аргумент-отримувач як вказівник - ок

Для інструкції `v.Scale(5)`, хоча `v` є значенням, а не вказівником, метод `Scale` автоматично викликається з вказівником у якості аргумента-отримувача.
Тобто для зручності Go інтерпретує інструкцію `v.Scale(5)` як `(&v).Scale(5)`, оскільки метод `Scale` має вказівник у якості аргумента-отримувача.

.play methods/indirection.go

* Методи та розіменування вказівника: продовження

Попереднє твердження правильне і в протилежному випадку.

Функції, які приймають значення у якості аргументу, повинні викликатися зі значеннями визначеного типу у якості параметра:

	var v Vertex
	fmt.Println(AbsFunc(v))  // ок
	fmt.Println(AbsFunc(&v)) // помила компіляції!

водночас методи зі значеннями у якості аргументів-отримувачів можуть викликатись, коли аргумент-отримувач є або значенням, або вказівником:

	var v Vertex
	fmt.Println(v.Abs()) // ок
	p := &v
	fmt.Println(p.Abs()) // ок

У цьому випадку виклик методу `p.Abs()` інтерпретується як `(*p).Abs()`.

.play methods/indirection-values.go

* Вибір між значенням або вказівником

Є дві причини використовувати вказівники.

Перша - це здатність методу змінювати значення, на які вказує вказівник.

Друга - щоб уникнути копіювання значення при кожному виклику метода.
Це найбільш актуально, коли структура є дуже великою.

У прикладі обидва методи `Scale` і `Abs` мають аргумент-отримувач `*Vertex`, хоча метод `Abs` не змінює ніяких значень.

Взагалі методи одного типу повинні мати аргумент-отримувач або вказівник, або значення, але не змішувати обидва типи.

.play methods/methods-with-pointer-receivers.go

* Інтерфейси (англ. interfaces)

_Інтерфейсний_тип_ - визначається як набір сигнатур методів; значення інтерфейсного типу може тримати будь-яке значення, яке реалізовує ці методи.

*Примітка:* рядок 24 є невірним, на що компілятор видасть помилку.
Змінна `v` має тип `Vertex` (не `*Vertex`) і таким чином не реалізовує інтерфейс `Abser`, тому неможливо виконати присвоювання до змінної `а`, яка має інтерфейсний тип `Abser`.

.play methods/interfaces.go

* Інтерфейси реалізовуються неявно

Тип реалізовує інтерфейс - оголошуючи його методи. Інакше кажучи, не треба явно вказувати, що тип реалізовує інтерфейс, наприклад як в Java, використовуючи ключове слово `implements`.

Таким чином, відбувається розʼєднання визначення інтерфейсу та його реалізації, що дає змогу використовувати інтерфейс у будь-якому пакеті без попереднього узгодження.

.play methods/interfaces-are-satisfied-implicitly.go

* Значення інтерфейсу

Під капотом значення інтерфейсу представлено парою із значення і конкретного типу:

  (value, type)

Значення інтерфейсу тримає значення конкретного типу, який лежить у його основі (базовий):

  (10, int32)

Виклик методу для значення інтерфейсу, виконує однойменний метод базового типу.

.play methods/interface-values.go

* Значення інтерфейсу з значенням базового типу nil (нульове значення).

Якщо значення базового типу інтерфейсу дорівнює `nil`, метод буде викликаний з аргументом-отримувачем `nil`.

У деяких мовах програмування це могло б призвести до виняткової ситуації, відомої як `null pointer exception`, але в Go це типово визначати методи, які викликаються з аргументом-отримувачем `nil` (як з методом `M` в прикладі).

Зауважте, що значення самого інтерфейсу не є `nil`, якщо значення базового типу дорівнює `nil`!

.play methods/interface-values-with-nil.go

* Нульове (nil) значення інтерфейсу

Нульове значення інтерфейсу означає, що ні базовий тип, ні значення цього типу не визначені.

Виклик методу нульового інтерфейсу є runtime-помилкою, тому що значення пари `(value, time)` всередині інтерфейсу не визначене, таким чином неможливо визначити який _певний_ метод потрібно викликати.

.play methods/nil-interface-values.go

* Порожній інтерфейс

Інтерфейсний тип, у якого не визначено жодного методу являє собою _порожній_інтерфейс_:

  interface{}

Порожньому інтерфейсному типу можна призначати значення будь-якого типу.

Порожній інтерфейс використовується в коді для обробки невизначеного типу.
Наприклад, `fmt.Print` приймає будь-яку кількість аргументів типу `interface{}`.

.play methods/empty-interface.go

* Твердження типу (англ. type assertions)

_Твердження_типу_ дає можливість доступу до базового значення інтерфейсу.

  t := i.(T)

Ця інструкція утверджує, що всередині інтерфейсу `i` є базовий тип `T` та присвоює значення цього типу змінній `t`.

Якщо базовий тип `T` інтерфейсу `i` не є таким (тобто відмінний від `T`), інструкція твердження призведе до критичної помилки, відомої як `panic`.

Для того, щоб _проконтролювати_ чи є базовий тип інтерфейсу конкретним типом, операція твердження може повертати два значення: базове значення типу, та bool, що вказує на успішність операції твердження.

  t, ok := i.(T)

Якщо базовим типом `i` є `T` - змінній `i` буде присвоєно значення базового типу, а `ok` буде мати значення `true`; інакше `ok` буде мати значення `false`, а `t` - нульове значення типу `T` і критичною помилки не станеться.

Зауважте подібність вищенаведеного синтаксису до того, який використовується при отриманні даних зі словника `map`.

.play methods/type-assertions.go

* Перемикач типів (англ. type switches)

_Перемикач_типів_ - це конструкція, яка дозволяє виконувати кілька операцій утвердження типу.

Перемикач типу працює як і звичайна інструкція перемикання, у якій у випадку (англ. case) визначені конкретні типи, а не значення, і ці типи порівнюються з базовими типами інтерфейсу.

  switch v := i.(type) {
	case T:
		// змінна v належить до типу T
	case S:
		// змінна v належить до типу S
	default:
		// не збіглося; змінна v має той самий тип, як і змінна i
	}

Оголошення у перемикачі типу має той же самий синтаксис, як і твердження типу: `i.(T)`, але конкретний тип `T` заміщується ключовим словом `type`.

Інструкція `switch` тестує чи значення базове значення інтерфейсу `i` належить до типу `T` або `S`.
У кожному випадку (case) `T` або `S`, змінна `v` буде мати тип або `T` або `S` - в залежності від того, до якого типу належить змінна `i`.
У випадку за замовченням (англ. default) (тобто коли немає збігів з будь-яким випадком) змінна `v` буде мати той тип, який насправді має базовий тип інтерфейсу.

.play methods/type-switches.go

* Інтерфейси рядка (англ. Stringers)

Один з найпопулярніших інтерфейсів в Go - це [[https://go.dev/pkg/fmt/#Stringer][`Stringer`]], що визначений у пакеті [[https://go.dev/pkg/fmt/][`fmt`]]

  type Stringer interface {
		String() string
	}

`Stringer` - це тип, який може описати себе рядком. Пакет `fmt` (і багато інших) очікують цей інтерфейс для друку значень.

.play methods/stringer.go

* Вправа: Stringers

Реалізуйте інтерфейс `fmt.Stringer` для типу `IPAddr`, щоб IP-адреса друкувалась наступним чином:

`IPAddr{1,`2,`3,`4}` повинна відображатися як `"1.2.3.4"`

.play methods/exercise-stringer.go

* Помилки (Errors)

Програми на Go визначають помилковий стан значенням `error`.

Тип `error` являє собою вбудований інтерфейс, подібний до `fmt.Stringer`:

	type error interface {
		Error() string
	}

(Як і з інтерфейсом `fmt.Stringer`, пакет `fmt` очікує інтерфейс `error`, коли виводить на другу помилку)

Функції часто повертають значення `error` і код, який викликає ці функції, повинен обробляти помилки порівнюючи їх з `nil`.

  i, err := strconv.Atoi("42")
	if err != nil {
		fmt.Printf("не вийшло конвертувати число: %v\n", err)
		return
	}
	fmt.Println("Конвертований int:", i)

Нульове значення `error` вказує на відсутність помилки; ненульове значення `error` вказує на наявність помилки.

.play methods/errors.go

* Вправа: Errors

Скопіюйте функцію `Sqrt` з [[/tour/flowcontrol/8][попередньої вправи]] і змініть її, щоб вона повертала `error`.

`Sqrt` повинна повертати ненульове значення помилки при негативному значенні аргументу.

Визначте новий тип

	type ErrNegativeSqrt float64

та визначте для нього метод з наступною сигнатурою - `Error() string`:

  func (e ErrNegativeSqrt) Error() string

Викликаючи цей метод `ErrNegativeSqrt(-2).Error()` - він повинен повертати `"cannot`Sqrt`negative`number:`-2"`.

*Примітка:* Якщо викликати `fmt.Sprint(e)` всередині `Error` - програма увійде в нескінченний цикл. Ви можете запобігти цьому, приводячи `e` до типу float64: `fmt.Sprint(float64(e))`. Чому так?

Змініть функцію `Sqrt`, щоб вона повертала `ErrNegativeSqrt`, при виклику функції з негативним аргументом.

.play methods/exercise-errors.go

* Інтерфейс Readers

Пакет `io` містить інтерфейс `io.Reader` для потоку даних для якого відбувається процес читання.

Стандартна бібліотека Go містить [[https://cs.opensource.google/search?q=Read%5C(%5Cw%2B%5Cs%5C%5B%5C%5Dbyte%5C)&ss=go%2Fgo][багато реалізацій]] цього інтерфейсу для файлів, мережевих з'єднань, інструментів компресії, шифрів та інших.

Інтерфейс `io.Reader` має метод `Read`:

	func (T) Read(b []byte) (n int, err error)

Метод `Read` заповнює даними слайс байтів `b` і повертає кількість записаних байтів та значення помилки. Він повертає помилку `io.EOF`, коли потік даних досяг кінця.

Код з прикладу [[https://go.dev/pkg/strings/#Reader][`strings.Reader`]] продукує і зчитує вивід 8 байтів за один раз.

.play methods/reader.go

* Вправа: Readers

Реалізуйте тип `Reader`, який продукує нескінченний потік ASCII символу `'A'`.

.play methods/exercise-reader.go

* Вправа: rot13Reader

Загальний патерн - це [[https://go.dev/pkg/io/#Reader][io.Reader]] який обертає ще один `io.Reader`, змінюючи потік даних будь-яким чином.

Наприклад, функція [[https://go.dev/pkg/compress/gzip/#NewReader][gzip.NewReader]] приймає `io.Reader` (потік даних компресії) і повертає `*gzip.Reader`, який теж реалізовує `io.Reader` (потік декомпресованих даних).

Реалізуйте `rot13Reader`, який в свою чергу реалізовує `io.Reader` і читає з `io.Reader`, модифікує потік даних застосовуючи [[https://uk.wikipedia.org/wiki/ROT13][rot13]] заміну шифру до всіх символів абетки.

Вам надається тип `rot13Reader`. Додайте метод `Read`, щоб він реалізовував `io.Reader`.

.play methods/exercise-rot-reader.go

* Вправа: Зображення

[[https://go.dev/pkg/image/#Image][Пакет]] визначає інтерфейс `Image`:

package image

	type Image interface {
		ColorModel() color.Model
		Bounds() Rectangle
		At(x, y int) color.Color
	}

*Примітка*: Значення типу `Rectangle`, яке повертає метод `Bounds`, насправді являє собою [[https://go.dev/pkg/image/#Rectangle][`image.Rectangle`]], як це зазначено в пакеті `image`.

(Дивіться [[https://go.dev/pkg/image/#Image][документацію]], щоб отримати подробиці.)

Типи `color.Color` та `color.Model` також є інтерфейсами, але ми будемо ігнорувати це використовуючи типи `color.RGBA` and `color.RGBAModel`. Ці інтерфейси і типи визначені в цьому [[https://go.dev/pkg/image/color/][image/color пакеті]]

.play methods/images.go

* Вправа: Зображення

Пам'ятаєте [[/tour/moretypes/18][генератор зображень]], який ми реалізували раніше? Реалізуймо ще один, але цього разу він буде повертати реалізацію інтерфейсу `image.Image` замість зрізу даних.

Визначте свій власний тип `Image`, реалізуйте обов'язковий [[https://go.dev/pkg/image/#Image][метод]], викличте `pic.ShowImage`.

Метод `Bounds` повинен повертати значення типу `image.Rectangle`, як це робить функція `image.Rect(0,`0,`w,`h)`.

Метод `ColorModel` повинен повертати значення типу `color.RGBAModel`.

Метод `At` повинен повертати колір; значення `v` в попередній реалізації генератора зображень відповідає структурному літералу `color.RGBA{v,`v,`255,`255}` у поточній реалізації.

.play methods/exercise-images.go

* Вітаємо!

Ви закінчили заняття!

Ви можете повернутися назад до списку [[/tour/list][модулів]] або перейти до [[javascript:click('.next-page')][наступного заняття]].




