Методи та інтерфейси
Цей урок охоплює такі поняття як методи та інтерфейси - конструкції, які визначають об'єкти та їх поведінку.

Автори Go
https://golang.org

* Методи

Go не має класів.
Але це не означає, що ви не можете визначати методи для типів.

Метод - це функція, в сігнатурі якої є аргумент-отримувач.

Отримувач знаходиться в окремому списку аргументів, між ключовим словом `func` і ім'ям метода.

У цьому пракладі метод `Abs` має аргумент-отримувач `v` типу `Vertex`.

.play methods/methods.go

* Методи - це функції

Пам'ятайте, що метод - це є функція з аргументом-отримувачем.

У прикладі, який ви зараз бачите, `Abs` написана як звичайна функція без будь-якої зміни її функціиональної поведінки.

* Методи, продовження

Ви також маєте змогу визначати методи для неструктурних типів.

У цьому прикладі ми бачимо числовий тип `MyFloat` для якого визначений метод `Abs`.

Тип аргумена-отримувача і метод, який ви визначаєте, повинні належити одному пакету.

Інакше кажучи, ви не можете визначити метод, тип аргумента-отримувача якого належить іньшому пакету, ніж пакет, до якого належить метод (це справедливо і для вбудованих типів даних, на кшталт `int`).

.play methods/methods-continued.go

* Вказівники у якості аргументів-отримувачів

Ви маєте змогу визначати методи, у яких аргументами-отримувачами виступють вказівники.

Це означає, що аргумент-отримувач має тип `*T` для деякого типу `T`. (Зауважте, що тип `T` не може бути вказівником сам по собі, наприклад `*int; інакше кажучи - вказівник на вказівник).

У прикладі ми бачимо, що у метода `Scale` аргумент-отримувач - це вказівник`*Vertex`.

Методи, з вказівниками у якості аргументів-отримувачів мають змогу модифікувати значення на які вказує вказівник (що і робить `Scale`).
Оскільки у функції методів часто закладають можливості модифікуції своїх аргументів-отримувачів, вказівники в якості аргументів-отримувачів дають більші можливостей, чим аргумент-отримувач в якості значення.

Спробуйте прибрати `*` з оголошення метода в рядку 18 і поспостерігайте, як зміниться поведінка програми.

Якщо аргумент-вказівник передається як значення, метод `Scale` оперує копією оригінального значення `Vertex` (тобто так само, як зі звичайним аргументом функції).
Метод `Scale` повинен мати вказівник у якості аргумента-отримувача, щоб мати змогу модифікувати значення `Vertex`, яке оголошено в функції `main`.

.play methods/methods-pointers.go

* Вказівники і функції

У прикладі, який ві бачите, методи `Abs` `Scale` переписані як функції.

А тепер ще раз, спробуйте прибрати `*` з рядка 18 (функція `Scale`).
Бачите, чому поведінка програми змінилась?
Які зміни необхідно внести в програму для її успішної компіляції? 
Якщо не впевнені, гортайте на наступну сторінку.

.play methods/methods-pointers-explained.go

* Методи та розіменування вказівника

Порівнюючи дві попередні програми, ви могли помітити, что функції з вказівниками у якості аргументів, повинні приймати вказівники у якості параметрів:

	var v Vertex
	ScaleFunc(v, 5)  // Помила компіляції!
	ScaleFunc(&v, 5) // ОК

в той же час, методи з вказівниками у якості аргементів-отримувачів, можуть викликатись коли аргумент-отримувач є або вказівником, або значенням:

	var v Vertex
	v.Scale(5)  // аргумент-отримувач як значення - OK
	p := &v
	p.Scale(10) // аргумент-отримувач як вказівник - OK

Для інструкції `v.Scale(5)`, хоча `v` є значенням, а не вказівником, метод `Scale` автоматично викликється з вказівником у якості аргумента-отримувача.
Тобто, для зручності, Go інтерпретує інструкцію `v.Scale(5)` як `(&v).Scale(5)`, оскільки метод `Scale` має вказівник у якості аргумента-отримувача.

.play methods/indirection.go

* Методи та розіменування вказівника (2)

Попереднє твердження вірно і у протилежному випадку.

Функції, які приймають значення у якості аргумента, повинні викликатися зі значеннями визначеного типа у якості параметра:

	var v Vertex
	fmt.Println(AbsFunc(v))  // OK
	fmt.Println(AbsFunc(&v)) // Помила компіляції!

в той же час, методи зі значеннями у якості аргументів-отримувачів, можуть викликатись коли аргумент-отримувач є або значення, або вказівником:

	var v Vertex
	fmt.Println(v.Abs()) // OK
	p := &v
	fmt.Println(p.Abs()) // OK

У цьому випадку викли метода `p.Abs()` інтерпретується як `(*p).Abs()`.

.play methods/indirection-values.go

* Вибір між значенням або вказівником

Є дві причини викристовувати вказвникі.

Перша, це здатність метода зінювати значення на які вказує вказівник.

Друга, щоб уникнути копіювання значення при кожному виклику метода.
Це найбільш актуально, коли структура є дуже великою.

У прикладі, обидва метода `Scale` і `Abs` мають аргумент-отримувач `*Vertex`, хоча метод `Abs` не звмінює ніяких значень.

Взагалі, методи одного типу повинні мати аргумент-отримувач або вказівник, або значення, но не змішувати обидва типа.

.play methods/methods-with-pointer-receivers.go

* Інтерфейси

Інтерфейсний_тип - визначається як набір сігнатур методів; значення інтерфейсного типа може тримати будь-яке значення, яке реалізовує ці методи.

*Примітка:* рядок 26 є невірним, на що компілятор видасть помилку.
Змінна v має тип Vertex (не *Vertex) і таким чином не реалізовує інтерфейс Abser, тому неможливо виконати присвоювання до змінної а, яка має інтерфейсний тип Abser.

.play methods/interfaces.go

* Інтерфейси реалізовуються неявно

Тип реалізовує інтерфейс - реалізовуя його методи. Інакше кажучи, не треба явно вказувати, що тип реалізовує інтерфейс, наприклад як в Java, викристовуючи ключове слово `implements`.

Таким чином, відбувається розєднання визначення інтерфейса та його реалізації, це дає змогу використовувати інтерфейс у будь-якому пакеті без попереднього узгодження.

.play methods/interfaces-are-satisfied-implicitly.go

* Значення інтерфейса

Під капотом, значення інтерфейса представлено кортежем із значення і конкретного типа:

  (value, type)

Значення інтерфейса тримає значення конкретного типа, який лежить у його основі (базовий):

  (10, int32)

Виклик метода для значення інтерфейсу, виконує однойменний метод базового типу.

.play methods/interface-values.go

* Значення інтерфейса з значенням базового типу nil (нульове значення).

Якщо значення базового типа інтерфейса дорівнює nil, метод буде викликаний з аргементом-отримувачем nil.

У деяких мовах програмування це могло б призвезти до винятновою ситуації, відомої як "null pointer exception", але в Go це типово визначати методи, які викликаються з аргументом-отримувачем nil (як з методом `M` в прикладі).

Зауважте, що значення самого інтерфейса не є nil, якщо значення базового типа дорівнює nil!

.play methods/interface-values-with-nil.go

* Нульове (nil) значення інтерфейса




