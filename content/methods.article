Методи та інтерфейси
Цей урок охоплює такі поняття як методи та інтерфейси - конструкції, які визначають об'єкти та їх поведінку.

Автори Go
https://golang.org

* Методи (англ. methods)

Go не має класів.
Але це не означає, що ви не можете визначати методи для типів.

Метод - це функція, в сигнатурі якої є аргумент-отримувач (англ. method receiver).

Отримувач знаходиться в окремому списку аргументів, між ключовим словом `func` і ім'ям метода.

У цьому пракладі метод `Abs` має аргумент-отримувач `v` типу `Vertex`.

.play methods/methods.go

* Методи - це функції

Пам'ятайте, що метод - це є функція з аргументом-отримувачем.

У прикладі, який ви зараз бачите, `Abs` написана як звичайна функція без будь-якої зміни її функціиональної поведінки.

* Методи, продовження

Ви також маєте змогу визначати методи для неструктурних типів.

У цьому прикладі ми бачимо числовий тип `MyFloat` для якого визначений метод `Abs`.

Тип аргумена-отримувача і метод, який ви визначаєте, повинні належити одному пакету.

Інакше кажучи, ви не можете визначити метод, тип аргумента-отримувача якого належить іньшому пакету, ніж пакет, до якого належить метод (це справедливо і для вбудованих типів даних, на кшталт `int`).

.play methods/methods-continued.go

* Вказівники у якості аргументів-отримувачів

Ви маєте змогу визначати методи, у яких аргументами-отримувачами виступють вказівники.

Це означає, що аргумент-отримувач має тип `*T` для деякого типу `T`. (Зауважте, що тип `T` не може бути вказівником сам по собі, наприклад `*int; інакше кажучи - вказівник на вказівник).

У прикладі ми бачимо, що у метода `Scale` аргумент-отримувач - це вказівник`*Vertex`.

Методи, з вказівниками у якості аргументів-отримувачів мають змогу модифікувати значення на які вказує вказівник (що і робить `Scale`).
Оскільки у функції методів часто закладають можливості модифікуції своїх аргументів-отримувачів, вказівники в якості аргументів-отримувачів дають більші можливостей, чим аргумент-отримувач в якості значення.

Спробуйте прибрати `*` з оголошення метода в рядку 18 і поспостерігайте, як зміниться поведінка програми.

Якщо аргумент-вказівник передається як значення, метод `Scale` оперує копією оригінального значення `Vertex` (тобто так само, як зі звичайним аргументом функції).
Метод `Scale` повинен мати вказівник у якості аргумента-отримувача, щоб мати змогу модифікувати значення `Vertex`, яке оголошено в функції `main`.

.play methods/methods-pointers.go

* Вказівники і функції

У прикладі, який ві бачите, методи `Abs` `Scale` переписані як функції.

А тепер ще раз, спробуйте прибрати `*` з рядка 18 (функція `Scale`).
Бачите, чому поведінка програми змінилась?
Які зміни необхідно внести в програму для її успішної компіляції? 
Якщо не впевнені, гортайте на наступну сторінку.

.play methods/methods-pointers-explained.go

* Методи та розіменування вказівника (англ. pointer inderection)

Порівнюючи дві попередні програми, ви могли помітити, що функції з вказівниками у якості аргументів, повинні приймати вказівники у якості параметрів:

	var v Vertex
	ScaleFunc(v, 5)  // помила компіляції!
	ScaleFunc(&v, 5) // ок

в той же час, методи з вказівниками у якості аргементів-отримувачів, можуть викликатись коли аргумент-отримувач є або вказівником, або значенням:

	var v Vertex
	v.Scale(5)  // аргумент-отримувач як значення - ок
	p := &v
	p.Scale(10) // аргумент-отримувач як вказівник - ок

Для інструкції `v.Scale(5)`, хоча `v` є значенням, а не вказівником, метод `Scale` автоматично викликється з вказівником у якості аргумента-отримувача.
Тобто, для зручності, Go інтерпретує інструкцію `v.Scale(5)` як `(&v).Scale(5)`, оскільки метод `Scale` має вказівник у якості аргумента-отримувача.

.play methods/indirection.go

* Методи та розіменування вказівника: продовження

Попереднє твердження вірно і у протилежному випадку.

Функції, які приймають значення у якості аргумента, повинні викликатися зі значеннями визначеного типа у якості параметра:

	var v Vertex
	fmt.Println(AbsFunc(v))  // ок
	fmt.Println(AbsFunc(&v)) // помила компіляції!

в той же час, методи зі значеннями у якості аргументів-отримувачів, можуть викликатись коли аргумент-отримувач є або значення, або вказівником:

	var v Vertex
	fmt.Println(v.Abs()) // ок
	p := &v
	fmt.Println(p.Abs()) // ок

У цьому випадку викли метода `p.Abs()` інтерпретується як `(*p).Abs()`.

.play methods/indirection-values.go

* Вибір між значенням або вказівником

Є дві причини викристовувати вказівники.

Перша - це здатність метода змінювати значення на які вказує вказівник.

Друга - щоб уникнути копіювання значення при кожному виклику метода.
Це найбільш актуально, коли структура є дуже великою.

У прикладі, обидва метода `Scale` і `Abs` мають аргумент-отримувач `*Vertex`, хоча метод `Abs` не змінює ніяких значень.

Взагалі, методи одного типу повинні мати аргумент-отримувач або вказівник, або значення, але не змішувати обидва типа.

.play methods/methods-with-pointer-receivers.go

* Інтерфейси (англ. interfaces)

_Інтерфейсний тип_ - визначається як набір сигнатур методів; значення інтерфейсного типа може тримати будь-яке значення, яке реалізовує ці методи.

*Примітка:* рядок 26 є невірним, на що компілятор видасть помилку.
Змінна `v` має тип `Vertex (не *Vertex)` і таким чином не реалізовує інтерфейс `Abser`, тому неможливо виконати присвоювання до змінної `а`, яка має інтерфейсний тип `Abser`.

.play methods/interfaces.go

* Інтерфейси реалізовуються неявно

Тип реалізовує інтерфейс - оголошуючи його методи. Інакше кажучи, не треба явно вказувати, що тип реалізовує інтерфейс, наприклад як в Java, викристовуючи ключове слово `implements`.

Таким чином, відбувається розʼєднання визначення інтерфейса та його реалізації, що дає змогу використовувати інтерфейс у будь-якому пакеті без попереднього узгодження.

.play methods/interfaces-are-satisfied-implicitly.go

* Значення інтерфейса

Під капотом, значення інтерфейса представлено парою із значення і конкретного типа:

  (value, type)

Значення інтерфейса тримає значення конкретного типа, який лежить у його основі (базовий):

  (10, int32)

Виклик метода для значення інтерфейсу, виконує однойменний метод базового типу.

.play methods/interface-values.go

* Значення інтерфейса з значенням базового типу nil (нульове значення).

Якщо значення базового типа інтерфейса дорівнює `nil`, метод буде викликаний з аргементом-отримувачем `nil`.

У деяких мовах програмування це могло б призвезти до вийняткової ситуації, відомої як `null pointer exception`, але в Go це типово визначати методи, які викликаються з аргументом-отримувачем `nil` (як з методом `M` в прикладі).

Зауважте, що значення самого інтерфейса не є `nil`, якщо значення базового типа дорівнює `nil`!

.play methods/interface-values-with-nil.go

* Нульове (nil) значення інтерфейса

Нульове значення інтерфейса означає, що ні базовий тип, ні значення цього типу не визначені.

Виклик метода нульового інтерфейса є runtime-помилкою, тому що значення пари `(value, time)` всередині інтерфейса не визначене, таким чином неможливо визначити який _певний_ метод потрібно викликати.

.play methods/nil-interface-values.go

* Порожній інтерфейс

Інтерфейсний тип, у якого не визначено жодного метода являє собою _порожній_інтерфейс_:

  interface{}

Порожньому інтерфейсному типу можна призначати значення будь-якого типу.

Порожній інтерфейс використовується в коді для обробки невизначеного типу.
Наприклад, `fmt.Print` приймає будь-яку кількість аргументів типа `interface{}`.

.play methods/empty-interface.go

* Твердження типу (англ. type assertions)

_Твердження_типу_ дає можливість доступу до базового значення інтерфейса.

  t := i.(T)

Ця інструкція утверджує, що всередині інтерфейса `i` є базовий тип `T` та присвоює значення цього типа змінній `t`.

Якщо базовий тип `T` інтерфейса `i` не є таким (тобто відмінний від `T`), інструкція твердження призведе до критичної помилки, відомої як `panic`.

Для того, щоб _проконтролювати_ чи є базовий тип інтерфейса конкретним типом, операція твердження може повертати два значення: базове значення типу, та bool, що вказує на успішність операції твердження.

  t, ok := i.(T)

Якщо базовим типом `i` є `T` - змінній `i` буде присвоєно значення базового типу, а `ok` буде мати значення `true`; інакше `ok` буде мати значення `false`, а `t` - нульове значення типу `T` і критичною помилки не станеться.

Зауважте подібність вищенаведеного синтаксису до того, який вікористовується при отриманні даних зі словника `map`.

.play methods/type-assertions.go

* Перемикач типів (англ. type switches)

_Перемикач типів_ - це конструкція, яка дозволяє виконувати кілька операцій утвердження типу.

Перемикач типу працює як і звичайна інструкція перемикання, у якій у випадку (англ. case) визначені конкретні типи, а не значення, і ці типи порівнюються з базовии типами інтерфейса.

  switch v := i.(type) {
	case T:
		// змінна v належить до типу T
	case S:
		// змінна v належить до типу S
	default:
		// не співпало; змінна v має той самий тип, як і змінна i
	}

Оголошення у перемикачі типу має той же самий синтаксис, як і твердження типу: `i.(T)`, але конкретний тип `T` заміщується ключовим словом `type`.

Інструкція `switch` тестує чи значення базове значення інтерфейса `i` належит до типу `T` або `S`.
У кожному випадку (case) `T` або `S`, змінна `v` буде мати тип або `T` або `S` - в залежності від того, до якого типа належить змінна `i`.
У випадку за замовченням (англ. default) (тобто, коли немає співпадінь з буд-яким випадком) змінна `v` буде мати той тип, який насправді має базовий тип інтерфейса.

.play methods/type-switches.go

* Інтерфейси рядка (англ. Stringers)

Один з найпопулярнішиї інтерфейсів в Go - це Stringer [[/pkg/fmt/#Stringer][`Stringer`]] визначений у пакеті [[/pkg/fmt/][`fmt`]]

  type Stringer interface {
		String() string
	}

`Stringer` - це тип, який може описати себе рядком. Пакет `fmt` (і багато інших) очікують цей інтерфейс для друку значень.

.play methods/stringer.go

* Вправа: Stringers

Реалізуйте інтерфейс `fmt.Stringer` для типу `IPAddr`, щоб IP-адреса друкувалась наступним чином:

`IPAddr{1,`2,`3,`4}` повинна відображатися як `"1.2.3.4"`

.play methods/exercise-stringer.go

* Помилки (Errors)

Програми на Go визначають помилковий стан значенням `error`.

Тип `error` являє собою вбудований інтерфейс, подібний до `fmt.Stringer`:

	type error interface {
		Error() string
	}

(Як і з інтерфейсом `fmt.Stringer`, пакет `fmt` очікуює інтерфейс `error`, коли виводить на друг полмилку)

Функції часто повертають значення `error` і код, який викликає ці функції, повинен обробляти помилки порівнюючи їх з `nil`.

  i, err := strconv.Atoi("42")
	if err != nil {
		fmt.Printf("не вийшло конвертувати число: %v\n", err)
		return
	}
	fmt.Println("Конвертований int:", i)

Нульове значення `error` вказує на відсутність помилки; не-нульове значення `error` вказує на наявність помилки.

.play methods/errors.go

* Вправа: Errors

Скопіюйте функцію `Sqrt` з [[/tour/flowcontrol/8][попередньої вправи]] і змініть її, щоб вона повертала `error`.

`Sqrt` повинна повертати не-нульове значення помилки при негативному значенні аргумента.

Визначте новий тип

	type ErrNegativeSqrt float64

та визначте для нього метод з наступною сигнатурою - `Error() string`:

  func (e ErrNegativeSqrt) Error() string

Викликаючи цей метод `ErrNegativeSqrt(-2).Error()` - він повинен повертати `"cannot`Sqrt`negative`number:`-2"`.

*Примітка:* Якщо викликати `fmt.Sprint(e)` всередині `Error` - програма увійде в бескінечний цикл. Ви можете запобігти цьому приводячи `e` до типу float64: `fmt.Sprint(float64(e))`. Чому так?

Змініть функцію `Sqrt`, щоб вона повертала `ErrNegativeSqrt`, при виклику функції з негативним аргументом.

.play methods/exercise-errors.go

* Інтерфейс Readers

Пакет `io` містить інтерфейс `io.Reader` для потоку даних для якого відбувається процес читання.

Стандартна бібліотека Go містить [[https://cs.opensource.google/search?q=Read%5C(%5Cw%2B%5Cs%5C%5B%5C%5Dbyte%5C)&ss=go%2Fgo][багато реалізацій]] цього інтерфейса для файлів, мережевих з`єднань, інструментів компресії, шифрів та інших.

Інтерфейс `io.Reader` має метод `Read`:

	func (T) Read(b []byte) (n int, err error)

Метод `Read` заповнює даними слайс байт `b` і повертає кількість записаних байт та значення помилки. Він повертає помилку `io.EOF`, коли потік даних досяг кінця.

Код з прикладу [[/pkg/strings/#Reader][`strings.Reader`]] продукує і зчитує вивід 8 байт за один раз.

.play methods/reader.go

* Вправа: Readers

Реалізуйте тип `Reader`, який продукує нескінченний потік ASCII символу `'A'`.

.play methods/exercise-reader.go

* Вправа: rot13Reader

Загальний патерн - це [[/pkg/io/#Reader][io.Reader]] який обертає ще один `io.Reader`, змінюючи потік даних будь-яким чином.

Наприклад, функція [[/pkg/compress/gzip/#NewReader][gzip.NewReader]] приймає `io.Reader` (потік даних компресії) і повертає `*gzip.Reader`, який теж реалізовує `io.Reader` (потік декомпресованих даних).

Реалізуйте `rot13Reader`, який в свою чергу реалізовує `io.Reader` і читає з `io.Reader`, модифікує потік даних застосовуючи [[https://en.wikipedia.org/wiki/ROT13][rot13]] заміну шифра до всіх символів абетки.

Вам надається тип `rot13Reader`. Додайте метод `Read`, щоб він реалізовував `io.Reader`.

.play methods/exercise-rot-reader.go

* Вправа: Зображення

[[/pkg/image/#Image][Пакет]] визначає інтерфейс `Image`:

package image

	type Image interface {
		ColorModel() color.Model
		Bounds() Rectangle
		At(x, y int) color.Color
	}

*Примітка*: Значення типу `Rectangle`, яке повертає метод `Bounds`, насправді являє собою [[/pkg/image/#Rectangle][`image.Rectangle`]], як це зазначено в пакеті `image`.

(Дивіться [[/pkg/image/#Image][документацію]] щоб отримати подробиці.)

Типи `color.Color` та `color.Model` також є інтерфейсами, але ми будемо ігнорувати це викристовуючи типи `color.RGBA` and `color.RGBAModel`. Ці інтерфейси і типи визначені в цьому [[/pkg/image/color/][image/color пакеті]]

.play methods/images.go

* Вправа: Зображення

Пам`ятаєте [[/tour/moretypes/18][генератор зображень]], який ми реалізували раніше? Давайте реалізуємо ще один, але цього разу він буде повертати реалізацію інтерфейса `image.Image` замість зріза даних.

Визначте свій власний тип `Image`, реалізуйте обов`язковий [[/pkg/image/#Image][метод]], викличте `pic.ShowImage`.

Метод `Bounds` повинен повертати значення типу `image.Rectangle`, як це робить функція `image.Rect(0,`0,`w,`h)`.

Метод `ColorModel` повинен повертати значення типу `color.RGBAModel`.

Метод `At` повинен повертати колір; значення `v` в попередній реалізації генератора зображень відповідає структурному літералу `color.RGBA{v,`v,`255,`255}` у поточній реалізації.

.play methods/exercise-images.go

* Ватаємо!

Ви закінчили заняття!

Ви можете повернутися назад до списку [[/tour/list][модулів]] або перейти до [[javascript:click('.next-page')][наступного заняття]].




