Конкурентність
Go надає конструкції для побудови конкурентності (англ. concurrency) як частину ядра мови програмування. Цей урок знайомить з ними та показує приклади використання.

Автори Go
https://golang.org

* Горутини (англ. goroutines)

_горутина_ - це легковагий потік керований середовищем виконання Go.

	go f(x, y, z)

стартує нову горутину що виконує

	f(x, y, z)

Обрахунок `f`, `x`, `y`, та `z` відбувається в поточній горутині, а виконання `f` відбувається вже в новій.

Виконання горутини відбувається в єдиному адресному просторі, тому доступ до спільної памʼяті треба синхронізовувати. Пакет [[/pkg/sync/][`sync`]] надає корисні примітиви для цього, проте вони не так часто потрібні, бо в Go вже існують вбудовані примітиви. (Докладніше на наступному слайді.)

.play concurrency/goroutines.go

* Канали (англ. channels)

Канали - типізовані провідники через які можна передавати та отримувати значення за допомогою оператора `<-`.

	ch <- v    // відправляємо значення v в канал ch
	v := <-ch  // отримуємо значення з каналу ch, та
	           // присвоюємо його змінній v.

(Данні рухаються в напрямку стрілки.)

Як і словники та зрізи, канали треба створити перед використанням:

	ch := make(chan int)

За замовчуванням, відправлення та отримання блокують виконання поточної горутини до готовності іншої сторони каналу. Це дає змогу горутині синхронізуватися без явного використання блокувань або умовних змінних.

Цей приклад підсумовує значення в зрізі, розподіляючи роботу між двома горутинами.
Остаточний результат обчислюється коли обидві горутини закінчують свої підрахунки.

.play concurrency/channels.go

* Буферизовані канали (англ. buffered channels)

Канали можуть бути буферизовані. Для ініціалізації буферизованого каналу, передайте довжину буфера як другий аргумент до `make`:

	ch := make(chan int, 100)

Відправлення в буферизований канал блокується тільки коли буфер заповнений. Отримання блокується тільки коли буфер порожній.

Змініть приклад так, щоб переповнити буфер і подивіться що відбудеться.

.play concurrency/buffered-channels.go

* Дії з каналами: `range` та `close`

Відправник може закрити канал, щоб вказати, що більше значень не буде відправлено. Отримувачі можуть перевірити, чи був канал закритий, присвоєнням другого параметра до виразу отримання:

	v, ok := <-ch

`ok` буде `false` якщо більше немає значень для отримання і канал закритий.

Цикл `for`i`:=`range`c` отримує значення з каналу поки він не буде закритий.

*Примітка:* Тільки відправник повинен закривати канал, а не отримувач. Відправлення в закритий канал призведе до паніки (англ. panic).

*Ще одна примітка:* Канали не схожі на файли; зазвичай вам не треба їх закривати. Закриття потрібне тільки коли треба повідомити отримувача, що більше значень не буде відправлено, наприклад для завершення циклу `range`.

.play concurrency/range-and-close.go

* Оператор `select`

Вираз `select` дозволяє горутині чекати на декілька операцій комунікації.

Вираз `select` блокується, поки один з випадків (англ. case) не може бути виконаний, а потім виконує цей випадок. Він обирає один випадок випадково, якщо декілька випадків готові.

.play concurrency/select.go

* Вибір за замовчуванням (англ. default case)

Випадок `default` в `select` виконується, якщо жоден інший випадок не готовий.

Використовуйте випадок `default` для спроби відправлення або отримання без блокування:

	select {
	case i := <-c:
		// виконується, якщо отримання з c не блокує
	default:
		// виконується, якщо отримання з c блокує
	}

.play concurrency/default-selection.go

* Вправа: Еквівалентні Бінарні Дерева

Може бути багато різних бінарних дерев з однаковою послідовністю значень, що зберігаються в них. Наприклад, на малюнку два бінарних дерева, що зберігають послідовність `1, 1, 2, 3, 5, 8, 13`.

.image /tour/static/img/tree.png

Функція для перевірки, чи два бінарних дерева зберігають однакову послідовність, досить складна у більшості мов. Ми використаємо конкурентність та канали Go для написання простого рішення.

Цей приклад використовує пакет `tree`, який визначає тип:

	type Tree struct {
		Left  *Tree
		Value int
		Right *Tree
	}


Опис продовжується на [[javascript:click('.next-page')][наступній сторінці]].

* Вправа: Еквівалентні Бінарні Дерева

*1.* Реалізуйте функцію `Walk`.

*2.* Протестуйте функцію `Walk`.

Функція `tree.New(k)` створює бінарне дерево з випадковою структурою (але завжди відсортованою), що зберігає значення `k`, `2k`, `3k`, ..., `10k`.

Створіть новий канал `ch` та запустіть walker:

	go Walk(tree.New(1), ch)

Тоді прочитайте та виведіть 10 значень з каналу. Це повинні бути числа 1, 2, 3, ..., 10.

*3.* Реалізуйте функцію `Same`, використовуючи `Walk`, для визначення чи зберігають `t1` та `t2` однакові значення.

*4.* Протестуйте функцію `Same`.

`Same(tree.New(1),`tree.New(1))` повинна повернути true, а `Same(tree.New(1),`tree.New(2))` повинна повернути false.

Документацію для `Tree` можна знайти [[https://godoc.org/golang.org/x/tour/tree#Tree][тут]].

.play concurrency/exercise-equivalent-binary-trees.go

* sync.Mutex

Ми бачили, як канали чудово працюють для комунікації між горутинами.

А що, якщо нам не потрібна комунікація? Що, якщо ми просто хочемо, щоб тільки
одна горутина могла одночасно отримати доступ до змінної, для уникнення конфліктів?

Ця концепція називається _взаємовиключенням_, а звичайна назва для структури даних, яка надає її, - _мʼютекс_ (англ. mutex).

Стандартна бібліотека Go надає взаємовиключення за допомогою структури
[[/pkg/sync/#Mutex][`sync.Mutex`]] та її двох методів:

- `Lock`
- `Unlock`

Ми можемо визначити блок коду, який буде виконуватися з взаємовиключенням, огорнувши
його викликом `Lock` та `Unlock`, як показано в методі `Inc`.

Ми також можемо використовувати `defer`, щоб впевнитися, що мʼютекс буде розблокований, як в методі `Value`.

.play concurrency/mutex-counter.go

* Вправа: Веб-краулер

В цій вправі ви використаєте можливості конкурентності Go для паралельного веб-краулера.

Змініть функцію `Crawl` так, щоб вона паралельно завантажувала URL-адреси без повторного завантаження однієї та тієї ж URL-адреси.

_Підказка_: ви можете зберігати кеш URL-адрес, які вже були завантажені, в словнику, але словники самі по собі
не є безпечними для конкурентного використання!

.play concurrency/exercise-web-crawler.go

* Що робити далі...

#appengine: Ви можете почати з
#appengine: [[/dl/][встановлення Go]].

#appengine: Якщо ви встановили Go,
The
[[/doc/][документація Go]] - чудове місце для
#appengine: продовження.
start.
Вона містить посилання, посібники, відео та багато іншого.

Для того, щоб дізнатися, як організувати та працювати з кодом Go, прочитайте [[/doc/code][Як писати код Go]].

Якщо вам потрібна допомога зі стандартною бібліотекою, перегляньте [[/pkg/][посібник по пакетам]]. Якщо вам потрібна допомога з самою мовою - ось [[/ref/spec][специфікація]], ви будете здивовані, але її досить легко зрозуміти.

Для подальшого ознайомлення з моделлю конкурентності Go, дивіться
[[https://www.youtube.com/watch?v=f6kdp27TYZs][Шаблони конкурентності в Go]]
([[/talks/2012/concurrency.slide][слайди]])
та
[[https://www.youtube.com/watch?v=QDDwwePbDtw][Просунуті шаблони конкурентності в Go]]
([[/talks/2013/advconc.slide][слайди]]),
а також прочитайте огляд коду
[[/doc/codewalk/sharemem/][Комунікація зі спільною памʼяттю]].

Для початку розробки веб-застосунків, дивіться
[[https://vimeo.com/53221558][Просте оточення для програмування]]
([[/talks/2012/simple.slide][слайди]])
та прочитайте посібник
[[/doc/articles/wiki/][Написання веб застосунків]].

[[/doc/codewalk/functions/][Функції першого порядку в Go]] - це цікавий огляд типів функцій Go.

[[/blog/][Блог Go]] містить великий архів інформативних статей про Go.

Відвідайте [[/][домашню сторінку Go]] для отримання додаткової інформації.
