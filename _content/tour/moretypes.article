Додаткові типи: структури, зрізи та карти.
Навчіться визначати типи на основі вже існуючих: в цьому уроці розглядаються структури, масиви, зрізи та карти.

Автори Go
https://golang.org

* Вказнівники

В Go є вказівники (також використовуються терміни "поінтери" та "покажчики").
Вказівник містить адресу пам'яті значення. ?????

Тип *T є вказівником на значення типу T. Його нульове значення nil.

	var p *int

Оператор `&` генерує вказівник на свій операнд.

	i := 42
	p = &i

Оператор `*` відображає значення, на яке посилається вказівник.

	fmt.Println(*p) // читання i через вказівник p
	*p = 21         // задати i через вказівник p

Це відомо як розіменування.

На відміну від C, Go не має арифметики вказівників.

.play moretypes/pointers.go

* структури

Структура `struct` це набір полів.

.play moretypes/structs.go

* Поля структури

Доступ до полів структури здійснюється за допомогою крапки.

.play moretypes/struct-fields.go

* Вказівник на структури

Доступ до полів структури можна отримати через поінтер структури.

Щоб отримати доступ до поля `X` структури, коли ми маємо вказівник структури `p`, ми можемо 
написати `(*p).X`.
Однак ця нотація є громіздкою, тому мова дозволяє нам натомість писати лише `p.X` без явного 
розіменування.

.play moretypes/struct-pointers.go

* Літерали структури

Літерал структури позначає щойно виділене значення структури шляхом переліку значень її полів.

Ви можете перерахувати лише підмножину полів, використовуючи синтаксис `Name:`. (І порядок іменованих полів не має значення.)

Спеціальний префікс `&` повертає вказівник на значення структури.

.play moretypes/struct-literals.go


* Масиви

Тип `[n]T` — це масив із `n` значень типу `T`.

Вираз

	var a [10]int

оголошує змінну `a` як масив із десяти цілих чисел.

Довжина масиву є частиною його типу, тому розмір масиву не можна змінити.
Це здається обмеженим, але не хвилюйтеся;
Go забезпечує зручний спосіб роботи з масивами.

.play moretypes/array.go


* Зрізи (слайси)

Масив має фіксований розмір.
З іншого боку, зріз — це гнучке представлення елементів 
масиву динамічного розміру.
На практиці зрізи зустрічаються набагато частіше, ніж масиви.

Тип '[]T' є зрізом з елементами типу 'T'.

Зріз формується шляхом зазначення двох індексів, нижньої 
та верхньої меж, розділених двокрапкою:

	a[нижня : верхня]

Це вибирає напіввідкритий діапазон, який включає перший 
елемент, але виключає останній.

Наступний вираз створює фрагмент, який включає елементи з 1 по 3 масиву 'a':

	a[1:4]

.play moretypes/slices.go


* Зрізи схожі на посилання на масиви

Фрагмент не зберігає жодних даних, 
він просто описує розділ основного масиву.

Зміна елементів фрагмента змінює відповідні 
елементи його основного масиву.

Інші фрагменти, які мають той самий базовий масив, побачать ці зміни.

.play moretypes/slices-pointers.go


* Літерали зрізів

Літерал слайсу схожий на літерал масиву без довжини.

Це літерал масиву:

	[3]bool{true, true, false}

І це створює той самий масив, що й вище, а 
потім будує фрагмент, який посилається на нього:

	[]bool{true, true, false}

.play moretypes/slice-literals.go


* Зріз за замовчуваням

Під час створення зрізу ви можете опустити верхню або нижню межі, щоб замість них використовувати стандартні значення.

За замовчуванням для нижньої межі встановлено нуль, а для верхньої – довжина зрізу.

Для масиву

	var a [10]int

ці вирази зрізу еквівалентні:

	a[0:10]
	a[:10]
	a[0:]
	a[:]

.play moretypes/slice-bounds.go


* Довжина і ємність зрізу

Зріз має як _довжину_, так і _ємність_.

Довжина слайсу - це кількість елементів, які він містить.

Ємність слайсу — це кількість елементів у базовому масиві, 
починаючи з першого елемента фрагмента.

Довжину та ємність слайсу `s` можна отримати за допомогою виразів 
`len(s)` і `cap(s)`.

Ви можете збільшити довжину слайсу, зробивши слайс повторно, 
за умови, що він має достатню ємність. 
Спробуйте змінити одну з операцій слайсу в прикладі програми, щоб розширити його 
за межі його можливостей, і подивіться, що станеться.

.play moretypes/slice-len-cap.go


* Nil slices

The zero value of a slice is `nil`.

A nil slice has a length and capacity of 0
and has no underlying array.

.play moretypes/nil-slices.go


* Creating a slice with make

Slices can be created with the built-in `make` function;
this is how you create dynamically-sized arrays.

The `make` function allocates a zeroed array
and returns a slice that refers to that array:

	a := make([]int, 5)  // len(a)=5

To specify a capacity, pass a third argument to `make`:

	b := make([]int, 0, 5) // len(b)=0, cap(b)=5

	b = b[:cap(b)] // len(b)=5, cap(b)=5
	b = b[1:]      // len(b)=4, cap(b)=4

.play moretypes/making-slices.go


* Slices of slices

Slices can contain any type, including other slices.

.play moretypes/slices-of-slice.go


* Appending to a slice

It is common to append new elements to a slice, and so Go provides a built-in
`append` function. The [[/pkg/builtin/#append][documentation]]
of the built-in package describes `append`.

	func append(s []T, vs ...T) []T

The first parameter `s` of `append` is a slice of type `T`, and the rest are
`T` values to append to the slice.

The resulting value of `append` is a slice containing all the elements of the
original slice plus the provided values.

If the backing array of `s` is too small to fit all the given values a bigger
array will be allocated. The returned slice will point to the newly allocated
array.

(To learn more about slices, read the [[/blog/go-slices-usage-and-internals][Slices: usage and internals]] article.)

.play moretypes/append.go


* Range

The `range` form of the `for` loop iterates over a slice or map.

When ranging over a slice, two values are returned for each iteration.
The first is the index, and the second is a copy of the element at that index.

.play moretypes/range.go

* Range continued

You can skip the index or value by assigning to `_`.

    for i, _ := range pow
    for _, value := range pow

If you only want the index, you can omit the second variable.

    for i := range pow

.play moretypes/range-continued.go

* Exercise: Slices

Implement `Pic`. It should return a slice of length `dy`, each element of which is a slice of `dx` 8-bit unsigned integers. When you run the program, it will display your picture, interpreting the integers as grayscale (well, bluescale) values.

The choice of image is up to you. Interesting functions include `(x+y)/2`, `x*y`, and `x^y`.

(You need to use a loop to allocate each `[]uint8` inside the `[][]uint8`.)

(Use `uint8(intValue)` to convert between types.)

.play moretypes/exercise-slices.go

* Maps

A map maps keys to values.

The zero value of a map is `nil`.
A `nil` map has no keys, nor can keys be added.

The `make` function returns a map of the given type,
initialized and ready for use.

.play moretypes/maps.go

* Map literals

Map literals are like struct literals, but the keys are required.

.play moretypes/map-literals.go

* Map literals continued

If the top-level type is just a type name, you can omit it from the elements of the literal.

.play moretypes/map-literals-continued.go

* Mutating Maps

Insert or update an element in map `m`:

	m[key] = elem

Retrieve an element:

	elem = m[key]

Delete an element:

	delete(m, key)

Test that a key is present with a two-value assignment:

	elem, ok = m[key]

If `key` is in `m`, `ok` is `true`. If not, `ok` is `false`.

If `key` is not in the map, then `elem` is the zero value for the map's element type.

*Note:* If `elem` or `ok` have not yet been declared you could use a short declaration form:

	elem, ok := m[key]

.play moretypes/mutating-maps.go

* Exercise: Maps

Implement `WordCount`.  It should return a map of the counts of each “word” in the string `s`. The `wc.Test` function runs a test suite against the provided function and prints success or failure.

You might find [[/pkg/strings/#Fields][strings.Fields]] helpful.

.play moretypes/exercise-maps.go

* Function values

Functions are values too. They can be passed around just like other values.

Function values may be used as function arguments and return values.

.play moretypes/function-values.go

* Function closures

Go functions may be closures. A closure is a function value that references variables from outside its body. The function may access and assign to the referenced variables; in this sense the function is "bound" to the variables.

For example, the `adder` function returns a closure. Each closure is bound to its own `sum` variable.

.play moretypes/function-closures.go

* Exercise: Fibonacci closure

Let's have some fun with functions.

Implement a `fibonacci` function that returns a function (a closure) that
returns successive [[https://en.wikipedia.org/wiki/Fibonacci_number][fibonacci numbers]]
(0, 1, 1, 2, 3, 5, ...).

.play moretypes/exercise-fibonacci-closure.go

* Congratulations!

You finished this lesson!

You can go back to the list of [[/tour/list][modules]] to find what to learn next, or continue with the [[javascript:click('.next-page')][next lesson]].
