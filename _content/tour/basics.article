Пакети, змінні та функції.
Вивчіть основні компоненти будь-якої програми на Go.

Автори Go
https://golang.org

* Пакети

Кожна програма Go складається з пакетів.

Програми починають працювати з пакета `main`.

Ця программа використовує пакети зі шляхами імпорту `"fmt"` та `"math/rand"`.

За домовленістю, назва пакету така ж сама, як і останній елемент шляху імпорту. Наприклад, пакет `"math/rand"` містить файли, що починаються зі слів `package rand`.

#appengine: *Примітка:* Середовище, в якому виконуються ці программи, є детермінованим (не змінюється), тому кожен раз виконання прикладів з `rand.Intn` будуть повертати однакові числа.

#appengine: Щоб побачити інші числа, потрібно встановити сид для генерації (дивіться [[pkg/math/rand/#Seed][`rand.Seed`]]). В цьому середовищі час не змінюється, тому для встановлення сиду вам потрібно використовувати щось інше замість [[pkg/time#Now][`time.Now`]].

.play basics/packages.go

* Імпорти

Цей код групує імпорт у єдині дужки.

Ви також можете написати іх окремо, наприклад:

	import "fmt"
	import "math"

Але хорошим стилем є группування імпортів.

.play basics/imports.go

* Експортовані найменування

У мові Go ім'я експортується, якщо воно починається з великої літери.
Наприклад, `Pizza` є експортованим ім'ям, так само як і `Pi`, які експортуються з
пакета `math`.

Слова "pizza" та "pi" не починаються з великої літери, тому вони не експортуються.

При імпорті пакета можна звертатися тільки до його експортованих імен.
Будь-які не експортовані імена не доступні ззовні пакету.

Запустіть код. Зверніть увагу на повідомлення про помилку.

Для виправлення помилки перейменуйте `math.pi` на `math.Pi` і повторіть спробу.

.play basics/exported-names.go

* Функції

Функція може приймати нуль або більше аргументів.

У даному прикладі функція `add` приймає два параметри типу `int`.

Зверніть увагу, що тип йде _після_ назви змінної.

(Детальніше про те, чому типи виглядають так, як вони виглядають, дивіться [[https://blog.golang.org/gos-declaration-syntax][статтю про синтаксис мови Go]].)

.play basics/functions.go

* Продовження функцій

Якщо двоє або більше параметрів функції мають спільний тип, то його можна не вказувати для всіх параметрів, окрім останнього.

У цьому прикладі ми скоротили

	x int, y int

до

	x, y int

.play basics/functions-continued.go

* Кілька результатів

Функція може повертати будь-яку кількість результатів.

Функція `swap` повертає дві строки.

.play basics/multiple-results.go

* Іменовані значення

Значення, що повертаються функцією Go, можуть бути іменованими. Вони розглядаються як змінні, визначені у верхній частині функції.

Ці імена повинні використовуватися для значень, що повертаються.

Оператор `return` без аргументів повертає іменовані значення, що повертаються. Це називається "голе" повернення.

Голі оператори повернення слід використовувати тільки в коротких функціях, як у наведеному прикладі. У довших функціях вони можуть погіршити читабельність.

.play basics/named-results.go

* Змінні

Інструкція `var` оголошує список змінних. Як і в списках аргументів функції, тип - в кінці.

Оператор `var` може бути на рівні пакету або функції. У даному прикладі ми бачимо обидва варіанти.

.play basics/variables.go

* Змінні зі значенням в ініціалізації

Оголошення `var` може включати ініціалізатори (тобто значення), по одному на змінну.

Якщо присутній ініціалізатор, то тип можна не вказувати, змінна прийме тип ініціалізатора.

.play basics/variables-with-initializers.go

* Об'явлення коротких змінних

Усередині функції замість оголошення `var` з неявним типом може використовуватись короткий оператор присвоювання `:=`.

Поза функцією кожен оператор починається з ключового слова (`var`, `func` і так далі), бо конструкція `:=` недоступна.

.play basics/short-variable-declarations.go

* Базові типи

Основними типами Go є

	bool

	string

	int  int8  int16  int32  int64
	uint uint8 uint16 uint32 uint64 uintptr

	byte // псевдонім для uint8

	rune // псевдонім для int32
	     // представляє символ Юнікоду (Unicode)

	float32 float64

	complex64 complex128

У прикладі показані змінні декількох типів,
а також те, що оголошення цих змінних може бути "об'єднане" в групи,
як і в операторах імпорту.

Типи `int`, `uint` та `uintptr` зазвичай мають розмір 32 біти на 32-бітних системах та 64 біти на 64-бітних системах.
Якщо вам потрібне ціле значення, ви повинні використовувати тип `int`, якщо тільки у вас немає особливих причин для використання змінної конкретного розміру.

.play basics/basic-types.go

* Нульові значення

Змінним, оголошеним без явного початкового значення, присвоюється їх
_нульове_значення_

Нульовим числом є:

- `0` для числових типів,
- `false` для булевого типу
- `""` (пусто) для строк.

.play basics/zero.go

* Перетворення типів

Вираз `T(v)` перетворює значення `v` в тип `T`.

Деякі числові перетворення:

	var i int = 42
	var f float64 = float64(i)
	var u uint = uint(f)

Або простіше:

	i := 42
	f := float64(i)
	u := uint(f)

На відміну від мови C, в Go присвоювання між елементами різних типів вимагає
_явного_ приведення.

Спробуйте прибрати перетворення `float64` або `uint` у прикладі і подивіться, що вийде.

.play basics/type-conversions.go

* Визначення типу

При оголошенні змінної без задання явного типу (з використанням синтаксису `:=` або синтаксису виразу `var`=`), тип змінної визначається за значенням у правій частині.

Коли змінна створюється на основі не вказанного типу, то її тип визначається типом правої частини виразу.

	var i int
	j := i // j також буде мати тип int

Але коли права частина містить нетипізовану числову константу, нова змінна може бути `int`, `float64` або `complex128` в залежності від написання(точності) константи:

	i := 42           // int
	f := 3.142        // float64
	g := 0.867 + 0.5i // complex128

Спробуйте змінити початкове значення `v` у прикладі коду і подивіться, як це вплине на його тип.

.play basics/type-inference.go

* Константи

Константи оголошуються як змінні, але з ключовим словом `const`.

Константи можуть бути символьними, рядковими, логічними або числовими значеннями.

Константи не можуть бути оголошені з використанням синтаксису `:=`.

.play basics/constants.go

* Числові константи

Числові константи є _високоточними_ значеннями.

Нетипізована константа приймає тип, необхідний для її контексту (коду, де вона буде використовуватися).

Спробуйте також надрукувати `needInt(Big)`.

(`int` може зберігати максимум 64-бітне ціле число, а іноді і менше).

.play basics/numeric-constants.go

* Вітаємо!

Ви закінчили цей урок!

Ви можете повернутись до списку [[/tour/list][модулів]], щоб знайти, чому вчитися далі, або перейти до [[javascript:click('.next-page')][наступного уроку]].